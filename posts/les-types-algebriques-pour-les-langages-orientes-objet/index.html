<!doctype html>
<html lang="en">
<head>
    <title>Les types algébriques pour les langages orientés objet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" type="application/rss+xml" title="Sadraskol's blog" href="https://sadraskol.com/feed">
    <style>
        fieldset {
            border: 0;
            padding: 0;
            margin: 0;
        }

        a {
            color: hsl(345.52, 100.0%, 77.25%);
            text-decoration: none
        }

        a:hover {
            text-decoration: underline;
            cursor: pointer
        }

        img {
            max-width: 100%;
        }

        body {
            margin: 0 0 0 0;
            font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
            background-color: hsl(22.11, 65.52%, 94.31%);
            color: hsl(344.0, 9.2%, 31.96%)
        }

        strong {
            color: hsl(345.0, 13.33%, 17.65%)
        }

        header {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            color: hsl(345.0, 13.33%, 17.65%)
        }

        header nav {
            padding-top: 1.0em;
            padding-bottom: 1.0em
        }

        .container {
            max-width: 900px;
            margin: 0 auto 0 auto;
            padding: 0 1em 0 1em;
        }

        figure img {
            display: block;
            margin: 0 auto 0.5em auto;
        }

        figure figcaption {
            text-align: center;
        }

        code {
            background-color: #fffffe;
        }

        pre code {
            background-color: #fffffe;
            overflow-x: auto;
            padding: 0.5em 0.5em 0.5em 0.5em;
            display: block;
        }

        blockquote {
            margin: 0 0 0 0;
            padding: 0.5em 1.5em 0.5em 3em;
            position: relative;
        }

        blockquote::before {
            content: "\201C";
            color: hsl(345.52, 100.0%, 77.25%);
            position: absolute;
            left: 0;
            font-size: 100px;
            line-height: 1;
        }

        .post-item {
            margin: 1.0em 0 0 0
        }

        .post-item:last-child {
            margin-bottom: 1.0em
        }

        .post-item__actions {
            display: flex;
            flex-direction: row;
            margin: 0 0 0 0;
            padding: 3.0px 0 0 0;
            list-style-type: none
        }

        .post-item__actions__item {
            position: relative;
            display: block;
            padding: 0 30.0px 0 0
        }

        .index-item {
            display: flex;
            margin: 1.0em 0 0 0;
        }
        .index-item:last-child {
            margin-bottom: 1.0em
        }
        .index-item_datetime {
            position: relative;
            display: block;
            padding: 0 30.0px 0 0;
            flex-basis: 8em;
            flex-shrink: 0;
        }

        .post-item__actions__item form button {
            background: none !important;
            border: none;
            padding: 0 !important;
            text-decoration: none;
            font: inherit;
            color: hsl(345.52, 100.0%, 77.25%);
        }

        .post-item__actions__item form button:hover {
            text-decoration: underline;
            cursor: pointer
        }

        #editor-content__textarea {
            width: 100%;
            height: 400px;
            padding: 1em;
            margin-bottom: 1em;
            display: block;
            resize: vertical;
        }

        .back-link {
            display: block;
            margin-bottom: 1em;
        }

        table th {
          text-align: center;
          padding: 8px 8px;
        }
        
        table td {
          text-align: center;
          padding: 8px 8px;
        }
        
        table tr {
          border-bottom: solid 1px #aaa;
        }

        table {
          border-collapse: collapse;
        }

        /* Github gist style from highlight js */
        .h-comment,
        .h-meta {
            color: #969896
        }

        .h-variable,
        .h-template-variable,
        .h-strong,
        .h-emphasis,
        .h-quote {
            color: #df5000
        }

        .h-keyword,
        .h-selector-tag,
        .h-type {
            color: #d73a49
        }

        .h-literal,
        .h-symbol,
        .h-bullet,
        .h-attribute {
            color: #0086b3
        }

        .h-section,
        .h-name {
            color: #63a35c
        }

        .h-tag {
            color: #333333
        }

        .h-title,
        .h-attr,
        .h-selector-id,
        .h-selector-class,
        .h-selector-attr,
        .h-selector-pseudo {
            color: #6f42c1
        }

        .h-addition {
            color: #55a532;
            background-color: #eaffea
        }

        .h-deletion {
            color: #bd2c00;
            background-color: #ffecec
        }

        .h-number {
            color: #005cc5
        }

        .h-string {
            color: #032f62
        }
    </style>
</head>
<body>
<div>
    <header class="container">
        <h1><a href="/">Sadraskol</a></h1>
    </header>
    <div class="container">
        
<h2>Les types algébriques pour les langages orientés objet</h2>
<time>02 February 2018</time>
<p>On pourrait renommer les languages fonctionnels (à l'exception d'Erlang, mais c'est une autre histoire) des languages algébriques à tel point que les structures algébriques sont leur outil de base. Nous allons essayer de montrer les analogies que ces structures ont avec les outils qui nous sont offerts dans les languages orientés objets et comment la réflexion en types algébriques permet de simplifier la modélisation de nos problèmes.</p>
<h2>Les types sommes</h2>
<p>Vous connaissez certainement déjà les types sommes : c'est le nom savant des énumerations. Vous savez ce qu'on utilise en Java pour désigner les méthodes Http ?</p>
<pre><code class="language-java"><span class="h-keyword">public</span> enum HttpMethod {
	DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT, TRACE
}
</code></pre>
<p>Cette structure est assez simple, alors pourquoi la nommer avec une opération algébrique comme la somme ? Qu'est-ce qu'on somme ici ? On parle de somme car on ajoute les possibilités. Ici le type <code>HttpMethod</code> est la somme de ses valeurs possibles (<code>DELETE</code>, <code>HEAD</code>, etc.) : 8. On parle de Cardinalité pour exprimer ce nombre. On dit que le Cardinal de l'ensemble <code>HttpMethod</code> est 8. On reviendra sur ce concept plus tard.</p>
<p>Les énumérations ne sont pourtant pas beaucoup utilisées en Java et malgré leurs propriétés intéressantes (pas de garbage collection, pas de problème d'instantiation ou utilisation dans les switch, etc.) elles ne sont pas importantes dans les patrons de conceptions. Alors comment ce type pourrait-il être central dans un autre language ? Voyons ce qu'est un type produit avant de répondre à cette question.</p>
<h2>Les types produits</h2>
<p>Un type produit est aussi très familier. Il correspond à la réunion de deux types. Si une personne est défini par son nom et son âge, on dira qu'il est le produit de ces deux types :</p>
<pre><code class="language-java"><span class="h-keyword">public</span> <span class="h-keyword">class</span> Person {
  <span class="h-keyword">private</span> final String name;
  <span class="h-keyword">private</span> final int age;
}
</code></pre>
<p>On parle de produit dans ce cas, car on peut avoir autant d'instance de <code>Person</code> qu'il y a de noms multiplié par le nombre d'ages possibles. Dans ce cas, il s'agit d'une multiplication d'infini. Vu ce cardinal, il est impossible de prévoir tous les cas. C'est pourtant le type que le language nous engage le plus à utiliser. C'est que ce type permet d'englober toutes les possibilités dans une seule structure.</p>
<p>Est-il possible de restreindre le nombre de valeurs possibles tout en profitant de la modélisation de domaine complexe que permet les types produits ?</p>
<h2>Les types algébriques</h2>
<p>Les beaucoup de <a href="https://en.wikipedia.org/wiki/Algebraic_data_type#Programming_languages_with_algebraic_data_types">languages</a> permettent d'utiliser une composition des types sommes et produits pour combiner les avantages des deux. Construisons un type qui modélise un cas concret, </p>
<pre><code class="language-haskell"><span class="h-keyword">data</span> Maybe a = Nothing | Just a

getHttpHeader = Just Get -- Maybe HttpMethod
noHttpHeader = Nothing -- Not available
</code></pre>
<p>Si l'on tente de calculer le cardinal de ce type algébrique, on voit que les valeurs possibles pour ce type sont : <code>1 + 1 * C(a)</code>, <code>C(a)</code> étant le cardinal du type <code>a</code>. La notion de somme et de produit transparait directement dans le calcul du cardinal. Dans le cas où <code>a</code> est un <code>HttpMethod</code>, <code>C(Maybe HttpMethod) == 8</code>. Ce qui est intéressant dans cette approche, c'est l'exhaustivité des types représentés. Par exemple, il est possible de représenter le score d'un point au tennis avec le type suivant :</p>
<pre><code class="language-haskell"><span class="h-keyword">data</span> Point = Zero | Fifteen | Thirty

<span class="h-keyword">data</span> Player = Player1 | Player2

<span class="h-keyword">data</span> GameScore
  = Score Point Point
  | GamePoint Player Point
  | Deuce
  | Advantage Player
  | Game Player
</code></pre>
<p>On pourrai montrer que le type <code>GameScore</code> implémente l'ensemble des scores possible pour un point de tennis. On peut même trivialement calculer l'ensemble des valeurs possibles :</p>
<pre><code>C(GameScore) == C(Point) * C(Point) + C(Player) * C(Point) + 1 + C(Player) + C(Player)
C(GameScore) == 3 * 3 + 2 * 3 + 1 + 2 + 2
C(GameScore) == 20
</code></pre>
<p>Il y a exactement 20 valeurs possibles (le code qui implémente le comportement est à la charge du lecteur 💪). Être capable de modéliser nos problèmes avec des types algébriques a l'énorme avantage de demander à ne résoudre que des valeurs possibles. Pas besoin de soucier des cas où il y aurait un score de <code>34 - 70</code> ou un score négatif. Si Haskell, et d'autres languages, permettent de simplement d'exprimer ces cas, comment utiliser ces outils dans un language comme Java ? Voyons cela ensemble.</p>
<h2>Les types algébriques en Java</h2>
<p>Il y a plusieurs alternatives pour implémenter correctement des types algébriques. Java n'offre pas d'outils de base pour les représenter, mais on peut utiliser un type purement produits avec une seule classe comme ceci :</p>
<pre><code class="language-java"><span class="h-keyword">class</span> GameScore {
  <span class="h-keyword">private</span> final int scorePlayer1;
  <span class="h-keyword">private</span> final int scorePlayer2;
  <span class="h-keyword">private</span> final GameStage stage;

  enum GameStage {
    Score, GamePoint, Deuce, Advantage, Game
  }
}
</code></pre>
<p>Le gros désavantage de ce genre d'approche (j'ai un peu exaggéré l'exemple, on aurait pu utiliser des classes plus fines) est facilement repérable à partir d'un calcul de cardinal : <code>C(GameScore) = C(int) * C(int) * 5</code>. Dans ce cas, <code>C(GameScore)</code> est largement supérieur au cas nominatif. De plus, il est de la responsabilité des méthodes manipulant ce type de ne pas se retrouver avec une valeur <code>(Score, 40, 40)</code> alors que c'est une valeur <code>Deuce</code> qui est attendue. Et puis que faire si on se retrouver dans la valeur <code>(Advantage, 15, 15)</code>, bref la complexité de cette implémentation est, à minima, dangereuse.</p>
<h3>Restreindre les valeurs possibles</h3>
<p>Pour résoudre cela, nous allons limiter les valeurs possibles. Dans un premier temps, on peut implémenter les énumérations simples que l'on a présentées en Haskell :</p>
<pre><code class="language-java">enum Player { PLAYER_1, PLAYER_2 }
enum Score { Zero, Fifteen, Thirty }
</code></pre>
<p>Il nous reste quand même le cas de l'implémentation du score à résoudre. Pour cela, on va utiliser l'outil de base des languages orientés objets : le polymorphisme ! Une implémentation d'interface pour chaque constructeur de valeur :</p>
<pre><code class="language-java"><span class="h-keyword">public</span> <span class="h-keyword">class</span> Score <span class="h-keyword">implements</span> GameScore {
  <span class="h-keyword">private</span> final Score scorePlayer1;
  <span class="h-keyword">private</span> final Score scorePlayer2;
}
<span class="h-keyword">public</span> <span class="h-keyword">class</span> GamePoint <span class="h-keyword">implements</span> GameScore {
  <span class="h-keyword">private</span> final Player gamePointPlayer;
  <span class="h-keyword">private</span> final Score otherPlayerScore;
}
<span class="h-keyword">public</span> <span class="h-keyword">class</span> Deuce <span class="h-keyword">implements</span> GameScore {}
<span class="h-keyword">public</span> <span class="h-keyword">class</span> Advantage <span class="h-keyword">implements</span> GameScore {
  <span class="h-keyword">public</span> final Player forPlayer;
}
<span class="h-keyword">public</span> <span class="h-keyword">class</span> Game <span class="h-keyword">implements</span> GameScore {
  <span class="h-keyword">public</span> final Player forPlayer;
}
</code></pre>
<p>Cette implémentation se rapproche très proche de l'implémentation en Haskell. On pourrait penser que son cardinal est la même. On a utilisé les mêmes constructeur avec les mêmes valeurs ! Or ce n'est pas le cas, car Java a une valeur qui est difficile à éviter lors de l'implémentation d'une classe : la valeur <code>null</code>. Si l'on explicite cette implémentation en Haskell, elle ressemblerait plutôt à ça :</p>
<pre><code class="language-haskell"><span class="h-keyword">data</span> Player = Player1 | Player2 | NullPlayer
<span class="h-keyword">data</span> GameScore
  = Score Point Point
  | GamePoint Player Point
  | Deuce
  | Advantage Player
  | Game Player
  | NullGameScore
-- etc.
</code></pre>
<p>Au lieu d'un cardinal du type algébrique <code>GameScore</code> : <code>C(GameScore) = 20</code>, on se retrouve avec <code>C(GameScore | Java) = 36</code>. Il y a 16 valeurs limites pour lesquels il va falloir se prémunir. Il existe des stratégies pour mitiger ce problème : on peut ignorer ces cas et risquer des <code>NullPointerException</code>, les prévenir avec des <code>checkNotNull</code>, etc. Aucune solution n'est meilleure qu'une autre et il faut faire avec, car c'est le language lui-même (et pas notre implémentation) qui produit des valeurs limites de nos types algébriques.</p>
<h2>Conclusion</h2>
<p>Les types algébriques sont un outil très efficace pour limiter les valeurs pour un type et donc alléger la charge mentale lors du développement d'une fonctionnalité. Les languages sont un auxiliaire à l'habilité du développeur et c'est de notre devoir de leur demander de coller au plus proche de ce que l'on souhaite exprimer.</p>

<div>
    <ul class="post-item__actions">
        <li class="post-item__actions__item"><a class="back-link" href="&#x2f;">All posts</a></li>
        <li class="post-item__actions__item"><a href="https://twitter.com/sadraskol">Twitter</a></li>
    </ul>
</div>

    </div>
</div>
</body>
</html>