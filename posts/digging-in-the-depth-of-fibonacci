<!doctype html>
<html lang="en">
<head>
    <title>Digging in the depth of Fibonacci</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" type="application/rss+xml" title="Sadraskol's blog" href="https://sadraskol.com/feed">
    <style>
        fieldset {
            border: 0;
            padding: 0;
            margin: 0;
        }

        a {
            color: hsl(345.52, 100.0%, 77.25%);
            text-decoration: none
        }

        a:hover {
            text-decoration: underline;
            cursor: pointer
        }

        img {
            max-width: 100%;
        }

        body {
            margin: 0 0 0 0;
            font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
            background-color: hsl(22.11, 65.52%, 94.31%);
            color: hsl(344.0, 9.2%, 31.96%)
        }

        strong {
            color: hsl(345.0, 13.33%, 17.65%)
        }

        header {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            color: hsl(345.0, 13.33%, 17.65%)
        }

        header nav {
            padding-top: 1.0em;
            padding-bottom: 1.0em
        }

        .container {
            max-width: 900px;
            margin: 0 auto 0 auto;
            padding: 0 1em 0 1em;
        }

        figure img {
            display: block;
            margin: 0 auto 0.5em auto;
        }

        figure figcaption {
            text-align: center;
        }

        code {
            background-color: #fffffe;
        }

        pre code {
            background-color: #fffffe;
            overflow-x: auto;
            padding: 0.5em 0.5em 0.5em 0.5em;
            display: block;
        }

        blockquote {
            margin: 0 0 0 0;
            padding: 0.5em 1.5em 0.5em 3em;
            position: relative;
        }

        blockquote::before {
            content: "\201C";
            color: hsl(345.52, 100.0%, 77.25%);
            position: absolute;
            left: 0;
            font-size: 100px;
            line-height: 1;
        }

        .post-item {
            margin: 1.0em 0 0 0
        }

        .post-item:last-child {
            margin-bottom: 1.0em
        }

        .post-item__actions {
            display: flex;
            flex-direction: row;
            margin: 0 0 0 0;
            padding: 3.0px 0 0 0;
            list-style-type: none
        }

        .post-item__actions__item {
            position: relative;
            display: block;
            padding: 0 30.0px 0 0
        }

        .index-item {
            display: flex;
            margin: 1.0em 0 0 0;
        }
        .index-item:last-child {
            margin-bottom: 1.0em
        }
        .index-item_datetime {
            position: relative;
            display: block;
            padding: 0 30.0px 0 0;
            flex-basis: 8em;
            flex-shrink: 0;
        }

        .post-item__actions__item form button {
            background: none !important;
            border: none;
            padding: 0 !important;
            text-decoration: none;
            font: inherit;
            color: hsl(345.52, 100.0%, 77.25%);
        }

        .post-item__actions__item form button:hover {
            text-decoration: underline;
            cursor: pointer
        }

        #editor-content__textarea {
            width: 100%;
            height: 400px;
            padding: 1em;
            margin-bottom: 1em;
            display: block;
            resize: vertical;
        }

        .back-link {
            display: block;
            margin-bottom: 1em;
        }

        table th {
          text-align: center;
          padding: 8px 8px;
        }
        
        table td {
          text-align: center;
          padding: 8px 8px;
        }
        
        table tr {
          border-bottom: solid 1px #aaa;
        }

        table {
          border-collapse: collapse;
        }

        /* Github gist style from highlight js */
        .h-comment,
        .h-meta {
            color: #969896
        }

        .h-variable,
        .h-template-variable,
        .h-strong,
        .h-emphasis,
        .h-quote {
            color: #df5000
        }

        .h-keyword,
        .h-selector-tag,
        .h-type {
            color: #d73a49
        }

        .h-literal,
        .h-symbol,
        .h-bullet,
        .h-attribute {
            color: #0086b3
        }

        .h-section,
        .h-name {
            color: #63a35c
        }

        .h-tag {
            color: #333333
        }

        .h-title,
        .h-attr,
        .h-selector-id,
        .h-selector-class,
        .h-selector-attr,
        .h-selector-pseudo {
            color: #6f42c1
        }

        .h-addition {
            color: #55a532;
            background-color: #eaffea
        }

        .h-deletion {
            color: #bd2c00;
            background-color: #ffecec
        }

        .h-number {
            color: #005cc5
        }

        .h-string {
            color: #032f62
        }
    </style>
</head>
<body>
<div>
    <header class="container">
        <h1><a href="/">Sadraskol</a></h1>
    </header>
    <div class="container">
        
<h2>Digging in the depth of Fibonacci</h2>
<time>24 October 2017</time>
<p>Not so long ago, I read an <a href="http://www.drincruz.com/blog/2017/08/19/what-does-fibonacci-look-like-in-elixir">article</a> on fibonacci. I suggested a more elegant solution to my eyes, but the problem kept bogging me. Let's get into it!</p>
<h2>The naïve recursive approach</h2>
<p>The first implementation, which reads like the mathematical formula, looks like this:</p>
<pre><code class="language-elixir"><span class="h-keyword">def</span> fib(0), <span class="h-keyword">do</span>: 1
<span class="h-keyword">def</span> fib(1), <span class="h-keyword">do</span>: 1
<span class="h-keyword">def</span> fib(n), <span class="h-keyword">do</span>: fib(n-1) + fib(n-2)
</code></pre>
<p>The main issue with this implementation is that the bigger the index you calculate, the exponentially bigger is number of operation needed. To show how, let's look at the following graph of calls of the <code>fib(5)</code>:</p>
<figure>
	<img src="https://s3.eu-central-1.amazonaws.com/sadraskol/fib-recursive-bomb.png" alt="Recursive Fibonacci implementation function call graph">
  <figcaption><i>Fig 1: Recursive Fibonacci implementation function call graph</i></figcaption>
</figure>
<p>As you can see <code>fib(2)</code> is calculated 3 times, which is a inefficient. The number of recursive calls of <code>fib</code> will grow exponentially as we advance in the sequence. My computer start having big problems when attempting to calculate <code>fib(35)</code>. You could even get the result before you computer, which is a pretty bad sign! Let's find another way to remove most of that calculation.</p>
<h2>Enters memoization</h2>
<p>Memoization is an optimisation technique that speeds up algorithm by saving intermediate function calls which are used multiple times. In our case, if we calculate <code>fib(n)</code>, we'll save every <code>fib(i)</code> with <code>i &amp;lt; n</code>.</p>
<p>Elixir is not designed to tackle this kind of optimisation, but you can find a javascript implementation <a href="https://medium.com/developers-writing/fibonacci-sequence-algorithm-in-javascript-b253dc7e320e">here</a></p>
<p>Although this technique will yield much better results at a benchmark, it is not yet an optimized version of the algorithm.</p>
<h2>Dynamic programming</h2>
<p>The last algorithm optimization available is called dynamic programming. It seems like a complex word, and it covers a lot of techniques but in the case of Fibonacci, the algorithm is elegant and intuitive.</p>
<p>The first thing you have to ask yourself is: &quot;How would I calculate <code>fib(5)</code>?&quot; Let's try to make it step by step:</p>
<pre><code>fib(2) = fib(1) + fib(0) = 1 + 1 = 2
fib(3) = fib(2) + fib(1) = 2 + 1 = 3
fib(4) = fib(3) + fib(2) = 3 + 2 = 5
fib(5) = fib(4) + fib(3) = 5 + 3 = 8
</code></pre>
<p>For each step you only used 3 explicit variables, <code>i</code>, <code>fib(i)</code>, <code>fib(i - 1)</code>, <code>fib(i - 2)</code> and an implicite one, the sequence number we calculate <code>n</code> (5 in this case). It's pretty simple to implement a function which will replicate this behavior:</p>
<pre><code class="language-elixir"><span class="h-keyword">def</span> fib(0), <span class="h-keyword">do</span>: 1
<span class="h-keyword">def</span> fib(1), <span class="h-keyword">do</span>: 1
<span class="h-keyword">def</span> fib(n), <span class="h-keyword">do</span>: dyna_fib(1, 1, n)

<span class="h-keyword">def</span> fib_step(result, _, 1), <span class="h-keyword">do</span>: result
<span class="h-keyword">def</span> fib_step(fib_i_minus_one, fib_i_minus_two, i) <span class="h-keyword">do</span>
	fib_step(fib_i_minus_one + fib_i_minus_two, last, i - 1)
<span class="h-keyword">end</span>
</code></pre>
<p>It's a very fast implementation, it's complexity drops to <code>O(n)</code>. This version calculates very easily the millionth element of the Fibonacci sequence!</p>
<h2>Using Maths at our advantage</h2>
<p>As you might know, the Fibonacci sequence is a mathematical object. Maybe maths have some interesting formulas, you can find the most interesting formula in the end of <a href="https://en.wikipedia.org/wiki/Fibonacci_number#Matrix_form">this chapter</a></p>
<blockquote>
<p>Fib(2n - 1) = F(n)² + F(n - 1)²</p>
<p>Fib(2n) = (2 * F(n - 1) + F(n)) * F(n)</p>
</blockquote>
<p>Those formulas are a huge improvement! They would allow to jump indices of the sequence by a factor of 2! This will allow to reduce the complexity to <code>O(log(n))</code>, which is quite impressive. The implementation is straight forward:</p>
<pre><code class="language-elixir"><span class="h-keyword">def</span> log_fib(0), <span class="h-keyword">do</span>: 0
<span class="h-keyword">def</span> log_fib(1), <span class="h-keyword">do</span>: 1
<span class="h-keyword">def</span> log_fib(2), <span class="h-keyword">do</span>: 1
<span class="h-keyword">def</span> log_fib(n) when rem(n, 2) == 1 <span class="h-keyword">do</span>
  <span class="h-comment"># Fib(2n - 1) = F(n)² + F(n - 1)²</span>
  i = div((n + 1), 2)
  first = log_fib(i)
  second = log_fib(i - 1)
  first * first + second * second
<span class="h-keyword">end</span>
<span class="h-keyword">def</span> log_fib(n) when rem(n, 2) == 0 <span class="h-keyword">do</span>
  <span class="h-comment"># Fib(2n) = (2 * F(n - 1) + F(n)) * F(n)</span>
  i = div(n, 2)
  first = log_fib(i)
  (2 * log_fib(i - 1) + first) * first
<span class="h-keyword">end</span>
</code></pre>
<h2>Using a library</h2>
<p>Instead of getting all the problems with implementing an optimized version, you should use a library that does the job for you. <a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005ffib_005fui">Gnu MP</a> is, as far as I know, the most optimized version of Fibonacci and uses a memoized version of the <code>O(log(n))</code> recursive algorithm.</p>
<p>I didn't think I would get so deep when starting the article. I wanted to show off with dynamic programming, but in this case it's not even the optimized version. The lesson of this article should be: always doubt on an opinion you have on a subject you don't know well. We tend to take our opinions for truth, but if we confront them to a methodological and rigorous research process, they always prove to be, at best, misleading.</p>

<div>
    <ul class="post-item__actions">
        <li class="post-item__actions__item"><a class="back-link" href="&#x2f;">All posts</a></li>
        <li class="post-item__actions__item"><a href="https://twitter.com/sadraskol">Twitter</a></li>
    </ul>
</div>

    </div>
</div>
</body>
</html>