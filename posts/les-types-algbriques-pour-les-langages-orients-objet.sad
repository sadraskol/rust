title = "Les types alg√©briques pour les langages orient√©s objet"
language = "fr"
publication_date = "2018-02-02T18:09:50.414671+00:00"
---- sadraskol ----
On pourrait renommer les languages fonctionnels (√† l'exception d'Erlang, mais c'est une autre histoire) des languages alg√©briques √† tel point que les structures alg√©briques sont leur outil de base. Nous allons essayer de montrer les analogies que ces structures ont avec les outils qui nous sont offerts dans les languages orient√©s objets et comment la r√©flexion en types alg√©briques permet de simplifier la mod√©lisation de nos probl√®mes.

## Les types sommes

Vous connaissez certainement d√©j√† les types sommes : c'est le nom savant des √©numerations. Vous savez ce qu'on utilise en Java pour d√©signer les m√©thodes Http ?

``` java
public enum HttpMethod {
	DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT, TRACE
}
```

Cette structure est assez simple, alors pourquoi la nommer avec une op√©ration alg√©brique comme la somme ? Qu'est-ce qu'on somme ici ? On parle de somme car on ajoute les possibilit√©s. Ici le type `HttpMethod` est la somme de ses valeurs possibles (`DELETE`, `HEAD`, etc.) : 8. On parle de Cardinalit√© pour exprimer ce nombre. On dit que le Cardinal de l'ensemble `HttpMethod` est 8. On reviendra sur ce concept plus tard.

Les √©num√©rations ne sont pourtant pas beaucoup utilis√©es en Java et malgr√© leurs propri√©t√©s int√©ressantes (pas de garbage collection, pas de probl√®me d'instantiation ou utilisation dans les switch, etc.) elles ne sont pas importantes dans les patrons de conceptions. Alors comment ce type pourrait-il √™tre central dans un autre language ? Voyons ce qu'est un type produit avant de r√©pondre √† cette question.

## Les types produits

Un type produit est aussi tr√®s familier. Il correspond √† la r√©union de deux types. Si une personne est d√©fini par son nom et son √¢ge, on dira qu'il est le produit de ces deux types :

``` java
public class Person {
  private final String name;
  private final int age;
}
```

On parle de produit dans ce cas, car on peut avoir autant d'instance de `Person` qu'il y a de noms multipli√© par le nombre d'ages possibles. Dans ce cas, il s'agit d'une multiplication d'infini. Vu ce cardinal, il est impossible de pr√©voir tous les cas. C'est pourtant le type que le language nous engage le plus √† utiliser. C'est que ce type permet d'englober toutes les possibilit√©s dans une seule structure.

Est-il possible de restreindre le nombre de valeurs possibles tout en profitant de la mod√©lisation de domaine complexe que permet les types produits ?

## Les types alg√©briques

Les beaucoup de [languages](https://en.wikipedia.org/wiki/Algebraic_data_type#Programming_languages_with_algebraic_data_types) permettent d'utiliser une composition des types sommes et produits pour combiner les avantages des deux. Construisons un type qui mod√©lise un cas concret, 

``` haskell
data Maybe a = Nothing | Just a

getHttpHeader = Just Get -- Maybe HttpMethod
noHttpHeader = Nothing -- Not available
```

Si l'on tente de calculer le cardinal de ce type alg√©brique, on voit que les valeurs possibles pour ce type sont : `1 + 1 * C(a)`, `C(a)` √©tant le cardinal du type `a`. La notion de somme et de produit transparait directement dans le calcul du cardinal. Dans le cas o√π `a` est un `HttpMethod`, `C(Maybe HttpMethod) == 8`. Ce qui est int√©ressant dans cette approche, c'est l'exhaustivit√© des types repr√©sent√©s. Par exemple, il est possible de repr√©senter le score d'un point au tennis avec le type suivant :

``` haskell
data Point = Zero | Fifteen | Thirty

data Player = Player1 | Player2

data GameScore
  = Score Point Point
  | GamePoint Player Point
  | Deuce
  | Advantage Player
  | Game Player
```

On pourrai montrer que le type `GameScore` impl√©mente l'ensemble des scores possible pour un point de tennis. On peut m√™me trivialement calculer l'ensemble des valeurs possibles :

```
C(GameScore) == C(Point) * C(Point) + C(Player) * C(Point) + 1 + C(Player) + C(Player)
C(GameScore) == 3 * 3 + 2 * 3 + 1 + 2 + 2
C(GameScore) == 20
```

Il y a exactement 20 valeurs possibles (le code qui impl√©mente le comportement est √† la charge du lecteur üí™). √ätre capable de mod√©liser nos probl√®mes avec des types alg√©briques a l'√©norme avantage de demander √† ne r√©soudre que des valeurs possibles. Pas besoin de soucier des cas o√π il y aurait un score de `34 - 70` ou un score n√©gatif. Si Haskell, et d'autres languages, permettent de simplement d'exprimer ces cas, comment utiliser ces outils dans un language comme Java ? Voyons cela ensemble.

## Les types alg√©briques en Java

Il y a plusieurs alternatives pour impl√©menter correctement des types alg√©briques. Java n'offre pas d'outils de base pour les repr√©senter, mais on peut utiliser un type purement produits avec une seule classe comme ceci :

``` java
class GameScore {
  private final int scorePlayer1;
  private final int scorePlayer2;
  private final GameStage stage;

  enum GameStage {
    Score, GamePoint, Deuce, Advantage, Game
  }
}
```

Le gros d√©savantage de ce genre d'approche (j'ai un peu exagg√©r√© l'exemple, on aurait pu utiliser des classes plus fines) est facilement rep√©rable √† partir d'un calcul de cardinal : `C(GameScore) = C(int) * C(int) * 5`. Dans ce cas, `C(GameScore)` est largement sup√©rieur au cas nominatif. De plus, il est de la responsabilit√© des m√©thodes manipulant ce type de ne pas se retrouver avec une valeur `(Score, 40, 40)` alors que c'est une valeur `Deuce` qui est attendue. Et puis que faire si on se retrouver dans la valeur `(Advantage, 15, 15)`, bref la complexit√© de cette impl√©mentation est, √† minima, dangereuse.

### Restreindre les valeurs possibles

Pour r√©soudre cela, nous allons limiter les valeurs possibles. Dans un premier temps, on peut impl√©menter les √©num√©rations simples que l'on a pr√©sent√©es en Haskell :

``` java
enum Player { PLAYER_1, PLAYER_2 }
enum Score { Zero, Fifteen, Thirty }
```

Il nous reste quand m√™me le cas de l'impl√©mentation du score √† r√©soudre. Pour cela, on va utiliser l'outil de base des languages orient√©s objets : le polymorphisme ! Une impl√©mentation d'interface pour chaque constructeur de valeur :

``` java
public class Score implements GameScore {
  private final Score scorePlayer1;
  private final Score scorePlayer2;
}
public class GamePoint implements GameScore {
  private final Player gamePointPlayer;
  private final Score otherPlayerScore;
}
public class Deuce implements GameScore {}
public class Advantage implements GameScore {
  public final Player forPlayer;
}
public class Game implements GameScore {
  public final Player forPlayer;
}
```

Cette impl√©mentation se rapproche tr√®s proche de l'impl√©mentation en Haskell. On pourrait penser que son cardinal est la m√™me. On a utilis√© les m√™mes constructeur avec les m√™mes valeurs ! Or ce n'est pas le cas, car Java a une valeur qui est difficile √† √©viter lors de l'impl√©mentation d'une classe : la valeur `null`. Si l'on explicite cette impl√©mentation en Haskell, elle ressemblerait plut√¥t √† √ßa :

``` haskell
data Player = Player1 | Player2 | NullPlayer
data GameScore
  = Score Point Point
  | GamePoint Player Point
  | Deuce
  | Advantage Player
  | Game Player
  | NullGameScore
-- etc.
```

Au lieu d'un cardinal du type alg√©brique `GameScore` : `C(GameScore) = 20`, on se retrouve avec `C(GameScore | Java) = 36`. Il y a 16 valeurs limites pour lesquels il va falloir se pr√©munir. Il existe des strat√©gies pour mitiger ce probl√®me : on peut ignorer ces cas et risquer des `NullPointerException`, les pr√©venir avec des `checkNotNull`, etc. Aucune solution n'est meilleure qu'une autre et il faut faire avec, car c'est le language lui-m√™me (et pas notre impl√©mentation) qui produit des valeurs limites de nos types alg√©briques.

## Conclusion

Les types alg√©briques sont un outil tr√®s efficace pour limiter les valeurs pour un type et donc all√©ger la charge mentale lors du d√©veloppement d'une fonctionnalit√©. Les languages sont un auxiliaire √† l'habilit√© du d√©veloppeur et c'est de notre devoir de leur demander de coller au plus proche de ce que l'on souhaite exprimer.